# -*- coding: utf-8 -*-
"""Homework7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16jRirocNxW0r-p8MaXQpLcVUUOeGpO8Z

TASK 1
    Create a class that implements a binary search tree and can perform basic
    operations such as insertion, deletion, and searching.
    
    TASK 2
    Create a class that implements a red black tree and can perform basic
    operations such as insertion, deletion, and searching.
    
    TASK 3
    Write a function that implements a merge sort algorithm.
    
    TASK 4
    Write a function that implements an insertion sort algorithm.
    
    TASK 5
    Write a function that implements a sorting algorithm in linear time.

#Task 1

Create a class that implements a binary search tree and can perform basic
operations such as insertion, deletion, and searching.
"""

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        
    def __repr__(self):
        return f'{self.value}'
      


class BST:
    def __init__(self):
        self.root = None


    # Insertion
    def insert(self, value):

      node = Node(value)
      if (self.root == None):
          self.root = node

          return
      prev = None
      temp = self.root
      while (temp != None):
          if (temp.value > value):
              prev = temp
              temp = temp.left
          elif(temp.value < value):
              prev = temp
              temp = temp.right
      if (prev.value > value):  prev.left = node
      else:   prev.right = node


    # Deletion
    def delete(self, value):    
      self.root = self.delete_helper(self.root, value)
        

    # Deletion helper
    def delete_helper(self, node, value):
      # Tree is empty
      if node is None: return None

      if value == node.value:
        # 1) No child
        if node.left is None and node.right is None:
            return None
        # 2) Rigth child
        elif node.left is None:
            return node.right
        # 3) Left child
        elif node.right is None:
            return node.left
        else:
        # 4) Has both children
            min_rigth = self.minimum(node.right)
            node.value = min_rigth.value
            node.right = self.delete_helper(node.right, min_rigth.value)
            return node
      # Search target in left branch
      elif value < node.value:
          node.left = self.delete_helper(node.left, value)
          return node
      # Search target in right branch
      else:
          node.right = self.delete_helper(node.right, value)
          return node
      

    # Minumum value
    def minimum(self, node):
        current = node
        while current.left is not None:  current = current.left
        return current

    # Searching
    def search(self, target):
      current = self.root
      while current.left != None or current.right != None:
        if current.value < target:
          current = current.right

        if current.value > target:
          current = current.left

        if current.value == target: 
          return True

      return False
                   
    # Printing function found from internet
    def tree_print(self, root, space=4):
      COUNT = [10]
      # Base case
      if (root == None):
          return
  
      space += COUNT[0]
      self.tree_print(root.right, space)
  
      print()
      for i in range(COUNT[0], space):
          print(end=" ")
      print(root.value)
  
      self.tree_print(root.left, space)

t = BST()
t.insert(5)
t.insert(7)
t.insert(1)
t.tree_print(t.root)
print("------------------------------")

t.delete(7)
t.tree_print(t.root)
print("------------------------------")

t.insert(10)
t.insert(11)
t.insert(12)
print(t.search(12))
print("------------------------------")
t.tree_print(t.root)
print("------------------------------")

"""#Task 2

Create a class that implements a red black tree and can perform basic
operations such as insertion, deletion, and searching.
"""

class Node:
    def __init__(self, key):
        self.key = key
        self.p = None
        self.left = None
        self.right = None
        self.color = 1
        # RED = 1, BLACK = 0


class RedBlackTree:
    def __init__(self):
        self.nil = Node(0)
        self.nil.color = 0
        self.nil.left = None
        self.nil.right = None
        self.root = self.nil

    # Search the tree
    def search(self, node, key):
        if node == self.nil or key == node.key:
            return node

        if key < node.key:
            return self.search(node.left, key)
        else:
            return self.search(node.right, key)

    # Rotate to left
    def left_rotate(self, x):
        y = x.right
        x.right = y.left
        if y.left != self.nil:
            y.left.p = x

        y.p = x.p
        if x.p == self.nil:
          self.root = y
        elif x == x.p.left:
          x.p.left = y
        else:
          x.p.right =y
        y.left = x
        x.p = y


    # Rotate to right
    def right_rotate(self, x):
        y = x.left
        x.left = y.right
        if y.right != self.nil:
            y.right.p = x

        y.p = x.p
        if x.p == self.nil:
            self.root = y
        elif x == x.p.right:
            x.p.right = y
        else:
            x.p.left = y
        y.right = x
        x.p = y


    # Insert
    def insert(self, key):
        z = Node(key)
        z.p = None
        z.key = key
        z.left = self.nil
        z.right = self.nil
        z.color = 1

        y = None
        x = self.root

        while x != self.nil:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right

        z.p = y
        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

        # Was getting a "NoneType object has no attribute color" error,
        # so this fixes it. ¯\_(ツ)_/¯

        if z.p == None: 
            z.color = None
            return

        self.insert_fixup(z)


    # Fixing after insertion
    def insert_fixup(self, z):
        while z.p.color == 1:
            if z.p == z.p.p.right:
                y = z.p.p.left
                # Case 1
                if y.color == 1:
                    z.p.color = 0
                    y.color = 0
                    z.p.p.color = 1
                    z = z.p.p
                else:
                    # Case 2
                    if z == z.p.left:
                        z = z.p
                        self.right_rotate(z)
                    # Case 3
                    z.p.color = 0
                    z.p.p.color = 1
                    self.left_rotate(z.p.p)
            else:
                y = z.p.p.right
                # Case 1
                if y.color == 1:
                    z.p.color = 0
                    y.color = 0
                    z.p.p.color = 1
                    z = z.p.p
                else:
                  # Case 2
                    if z == z.p.right:
                        z = z.p
                        self.left_rotate(z)
                    # Case 3 
                    z.p.color = 0
                    z.p.p.color = 1
                    self.right_rotate(z.p.p)
            if z == self.root:
                break
        self.root.color = 0


    # Main delete
    def delete(self, key):
        self.delete_helper(self.root, key)
        
    # Delete helper
    def delete_helper(self, node, key):
        z = self.search(self.root,key)

        if z == self.nil:
            print(f"Cannot find key({key}) in the tree")
            return

        y = z
        y_original_color = y.color
        if z.left == self.nil:
            x = z.right
            self.rb_transplant(z, z.right)
        elif z.right == self.nil:
            x = z.left
            self.rb_transplant(z, z.left)
        else:
            y = self.minimum(z.right)
            y_original_color = y.color
            x = y.right
            if y.p == z:
                x.p = y
            else:
                self.rb_transplant(y, y.right)
                y.right = z.right
                y.right.p = y

            self.rb_transplant(z, y)
            y.left = z.left
            y.left.p = y
            y.color = z.color
        if y_original_color == 0:
            self.delete_fixup(x)


    # Fixing after deletion
    def delete_fixup(self, x):
        while x != self.root and x.color == 0:
            if x == x.p.left:
                w = x.p.right
                if w.color == 1:
                    # Case 1 
                    w.color = 0
                    x.p.color = 1
                    self.left_rotate(x.p)
                    w = x.p.right

                if w.left.color == 0 and w.right.color == 0:
                  # Case 2
                    w.color = 1
                    x = x.p
                else:
                    if w.right.color == 0:
                      # Case 3
                        w.left.color = 0
                        w.color = 1
                        self.right_rotate(w)
                        w = x.p.right
                    # Case 4
                    w.color = x.p.color
                    x.p.color = 0
                    w.right.color = 0
                    self.left_rotate(x.p)
                    x = self.root
            else:
                w = x.p.left
                if w.color == 1:
                    # Case 1
                    w.color = 0
                    x.p.color = 1
                    self.right_rotate(x.p)
                    w = x.p.left

                if w.right.color == 0 and w.right.color == 0:
                    # Case 2
                    w.color = 1
                    x = x.p
                else:
                    if w.left.color == 0:
                        # Case 3
                        w.right.color = 0
                        w.color = 1
                        self.left_rotate(w)
                        w = x.p.left
                    # Case 4
                    w.color = x.p.color
                    x.p.color = 0
                    w.left.color = 0
                    self.right_rotate(x.p)
                    x = self.root
        x.color = 0


    # Trasnsplant function which is used in deletion
    def rb_transplant(self, u, v):
        if u.p == None:
            self.root = v
        elif u == u.p.left:
            u.p.left = v
        else:
            u.p.right = v
        v.p = u.p

    
    # Minimum value
    def minimum(self, node):
        while node.left != self.nil:
            node = node.left
        return node


    # Maximum value
    def maximum(self, node):
        while node.right != self.nil:
            node = node.right
        return node


    # Printing function found from internet
    def print_helper(self, node, indent, last):
        import sys
        if node != self.nil:
            sys.stdout.write(indent)
            if last:
                sys.stdout.write("R----")
                indent += "     "
            else:
                sys.stdout.write("L----")
                indent += "|    "

            s_color = "RED" if node.color == 1 else "BLACK"
            print(str(node.key) + "(" + s_color + ")")
            self.print_helper(node.left, indent, False)
            self.print_helper(node.right, indent, True)


    # Main print
    def print_tree(self):
        self.print_helper(self.root, "", True)

bst = RedBlackTree()

bst.insert(15)
bst.insert(20)
bst.insert(7)
bst.insert(30)
bst.insert(100)
bst.insert(1)
bst.insert(51)
bst.insert(3)

bst.print_tree()

print()
print("After deletion")
bst.delete(30)
bst.print_tree()

"""#Task 3

Write a function that implements a merge sort algorithm.
"""

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)

def merge(left, right):
    result = []
    l, r = 0, 0
    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    while l < len(left):
        result.append(left[l])
        l += 1
    while r < len(right):
        result.append(right[r])
        r += 1
    return result

a = [5,4,1,2,1,99,7,7,7,8,9,6,40]
a = merge_sort(a)
a

"""#Task 4

Write a function that implements an insertion sort algorithm.
"""

def insertion(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

print(insertion(a))

"""#Task 5

Write a function that implements a sorting algorithm in linear time.
"""

def counting_sort(arr):
    max_element = max(arr)
    count = [0] * (max_element + 1)

    for element in arr:  count[element] += 1

    for i in range(1, max_element + 1):   count[i] += count[i - 1]
    
    result = [0] * len(arr)

    for i in range(len(arr) - 1, -1, -1):
        result[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1
        
    return result

print(counting_sort(a))